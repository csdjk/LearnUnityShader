// Toony Colors Pro+Mobile 2
// (c) 2014-2020 Jean Moreno

#NAME=Default (Universal Pipeline)
#ID=TEMPLATE_URP
#TEMPLATE_KEYWORDS=TEMPLATE_LWRP
#SG2

#================================================================================================================================================================================================================================================================

#MODULES

# needed by Shader Generator 2:
NoTile Sampling
HSV
Screen Space UV
Hash Functions

# lighting:
Ramp Shading LWRP
ShadowHSV
Specular
Rim Lighting
Reflection
Subsurface Scattering
MatCap
Custom Ambient

# surface:
AlbedoHSV
Normal Mapping
Texture Blending
Triplanar

# stylization:
NdotL Stylization
Sketch
Outline

# special effects:
Dissolve
Vertical Fog
Wind
VertExmotion
CurvedWorld

#END

#================================================================================================================================================================================================================================================================

#FEATURES

[[MODULE:FEATURES:Screen Space UV]]
dd_start	lbl=LIGHTING
---
[[MODULE:FEATURES:Ramp Shading LWRP]]
sngl	lbl=Bypass Additional Lights Falloff		kw=BYPASS_LIGHT_FALLOFF								tt="Bypass the point and spot light falloff calculation and only use the TCP2 ramp shading instead"
---
mult	lbl=Shadow Color Shading		kw=All Lights|,Main Directional Light|SHADOW_COLOR_MAIN_DIR		tt="How the shadow color is applied, either globally across all lights, or based on the main directional light only (same behavior as in the legacy render pipeline)"	help="featuresreference/lighting/shadowcolorshading"
mult	lbl=Clamp Lights Intensities	kw=Off|,All Lights|CLAMP_LIGHTS_INTENSITY,Additional Lights|CLAMP_LIGHTS_INTENSITY_ADD		excl=SHADOW_COLOR_MAIN_DIR	indent	visibleIf=!SHADOW_COLOR_MAIN_DIR		tt="Ensure that the illumination received by all lights combined will never exceed a specific value (1 by default)"
mult	lbl=Shadow Color Mode			kw=Multiply|,Replace Color|SHADOW_COLOR_LERP					tt="How to blend the shadow color on the model"		help="featuresreference/lighting/shadowcolormode"
mult	lbl=Shadow Color (other lights)	kw=Off|,Enabled|ENABLE_SHADOW_2ND_LIGHTS,Enabled (clamped)|ENABLE_SHADOW_2ND_LIGHTS_SAT		needs=SHADOW_COLOR_MAIN_DIR		tt="Enable shadow color for additive lights; this means that the model will get some tint in unlit areas when using secondary lights."
[[MODULE:FEATURES:ShadowHSV]]
---
[[MODULE:FEATURES:Specular]]
---
sngl	lbl=Emission					kw=EMISSION		help="featuresreference/lighting/emission"		tt="Adds emission to the shader.  Modify the Emission property to change the source input (color, texture, etc.) and possibly use a mask."
---
[[MODULE:FEATURES:Rim Lighting]]
---
[[MODULE:FEATURES:Subsurface Scattering]]
---
sngl	lbl=Reflection Probes			kw=GLOSSY_REFLECTIONS																	tt="Enable reflection probes or skybox reflection support"
[[MODULE:FEATURES:Reflection]]
sngl	lbl=Make Reflections Optional	kw=REFLECTION_SHADER_FEATURE		needsOr=REFLECTION_CUBEMAP,GLOSSY_REFLECTIONS		tt="Will make reflections optional in the material inspector, using a shader keyword"
---
[[MODULE:FEATURES:MatCap]]
---
subh	lbl=Ambient Lighting/Indirect Diffuse		help="featuresreference/lighting/ambientlighting/indirectdiffuse"
sngl	lbl=Disable Ambient Lighting	kw=NO_AMBIENT				tt="Disable ambient lighting calculated by the engine (as defined in the Lighting Settings)"
[[MODULE:FEATURES:Custom Ambient]]
sngl	lbl=Occlusion					kw=OCCLUSION		tt="Adds ambient lighting occlusion support.  Modify the Occlusion property to change the source input (texture, vertex color, etc.)."
sngl	lbl=View Dir Ambient Sampling	kw=AMBIENT_VIEW_DIR		tt="Use the view direction to sample Light Probes (ambient), instead of the normal direction.  This makes the ambient color to always be the same for the whole model, which can be interesting to get a flat effect while still getting dynamic ambient from the skybox for example."
sngl	lbl=Make Ambient Optional		kw=AMBIENT_SHADER_FEATURE	tt="Will make ambient/indirect diffuse lighting optional in the material inspector, using a shader keyword"
---
dd_end

dd_start	lbl=SURFACE
---
[[MODULE:FEATURES:AlbedoHSV]]
---
[[MODULE:FEATURES:Normal Mapping]]
---
[[MODULE:FEATURES:Texture Blending]]
---
[[MODULE:FEATURES:Triplanar]]
dd_end
dd_start	lbl=STYLIZATION
---
[[MODULE:FEATURES:NdotL Stylization]]
[[MODULE:FEATURES:Sketch]]
[[MODULE:FEATURES:Outline]]
dd_end
dd_start	lbl=SPECIAL EFFECTS
---
sngl	lbl=Silhouette Pass				kw=PASS_SILHOUETTE													tt="Adds a silhouette pass, to show the object when it is behind obstacles"
sngl	lbl="URP Renderer Feature"		kw=SILHOUETTE_URP_FEATURE		needs=PASS_SILHOUETTE	indent		tt="Set the silhouette pass to be used as a Renderer Feature (see documentation)"
sngl	lbl=Stencil Mask				kw=SILHOUETTE_STENCIL	needs=PASS_SILHOUETTE			indent		tt="Use the Stencil Buffer as a mask for the silhouette, to prevent transparency issues with non-convex meshes or multiple meshes"
---
[[MODULE:FEATURES:Wind]]
---
[[MODULE:FEATURES:Dissolve]]
---
[[MODULE:FEATURES:Vertical Fog]]
dd_end
dd_start	lbl=TRANSPARENCY/BLENDING
---
mult	lbl=Blending				kw=Off|,Alpha Blending|ALPHA_BLENDING,Alpha Blending Premultiplied|ALPHA_BLENDING_PREMULT,Additive|ADDITIVE_BLENDING,Multiplicative|MULTIPLICATIVE_BLENDING,Custom Blending|CUSTOM_BLENDING	toggles=SHADER_BLENDING		tt="Enable blending on the shader"
mult_fs		lbl=Blend Operation		kw=BLEND_OP		options=Default|,Custom|Constant,Material Property|Material Property		shader_property="Blend Operation"		tt="Enable blend operation control"
warning	msgType=info	needs=CUSTOM_BLENDING	lbl=Look at the <b>Shader Properties</b> tab to setup the custom blending states.
space	space=4			needs=CUSTOM_BLENDING
#---
#sngl	lbl=Depth pre-pass		kw=DEPTH_PREPASS		tt="Adds a depth only shader pass, to prevent parts of the mesh from being visible through itself."
#NOTE: not working currently, the additional pass seems to always be drawn after the UniversalForward one, never before, so we can't draw to the depth buffer beforehand.
---
sngl	lbl=Alpha Testing (Cutout)		kw=ALPHA_TESTING
sngl	lbl="Alpha to Coverage"			kw=ALPHA_TO_COVERAGE		needs=ALPHA_TESTING							indent		tt="Enables Alpha to Coverage, which allows MSAA anti-aliasing to be used with alpha testing"
sngl	lbl="Disable alpha sharpening"	kw=ALPHA_TO_COVERAGE_RAW	needs=ALPHA_TESTING,ALPHA_TO_COVERAGE		indent=2	tt="Disables screen-space alpha sharpening, which is used to get proper anti-aliasing with Alpha to Coverage"
dd_end
dd_start	lbl=SHADER STATES
---
mult_fs		lbl=Face Culling (Double-sided)		kw=CULLING	options=Default|,Custom|Constant,Material Property|Material Property		shader_property="Face Culling"		tt="Enable face culling control"
mult	lbl=Backface Lighting		kw=Off|,Flip Normal (Z)|BACKFACE_LIGHTING_Z,Flip Normal (XYZ)|BACKFACE_LIGHTING_XYZ		indent	tt="Invert the normals on backfaces for accurate lighting calculation (this may not work properly with shadows and introduce other artifacts)"
---
mult_fs		lbl=Depth Write			kw=ZWRITE		options=Default|,Custom|Constant,Material Property|Material Property	shader_property="Depth Write"		tt="Enable depth write (ZWrite) value control"
mult_fs		lbl=Depth Test			kw=ZTEST		options=Default|,Custom|Constant,Material Property|Material Property	shader_property="Depth Test"		tt="Enable depth test (ZTest) control"
---
mult	lbl=Stencil					kw=Off|,Custom|STENCIL				tt="Enable stencil control (see the Properties tab)"
warning	msgType=info	needs=STENCIL	lbl=Look at the <b>Shader Properties</b> tab to setup the stencil states.
space	space=4			needs=STENCIL
---
keyword	lbl=Shader Target	kw=SHADER_TARGET	forceKeyword=true	values=2.0 (Old hardware)|2.0,2.5 (Low-end mobile devices)|2.5,3.0 (Recommended default)|3.0,3.5|3.5,4.0|4.0,4.5|4.5,4.6|4.6,5.0|5.0		default=2
warning	msgType=info		lbl=Use <b>Shader Target 2.5</b> for maximum compatibility across mobile devices (OpenGL ES 2.0 with no extensions).  Increase the number if the shader fails to compile (not enough instructions or interpolators).
dd_end
dd_start	lbl=OPTIONS
---
sngl		lbl=Disable Shadow Receiving			kw=DISABLE_SHADOW_RECEIVING
sngl		lbl=Disable Shadow Casting				kw=DISABLE_SHADOW_CASTING
sngl		lbl=Disable Additional Lights			kw=DISABLE_ADDITIONAL_LIGHTS
sngl		lbl=Enable Fog							kw=FOG
sngl		lbl=Enable Lightmaps					kw=ENABLE_LIGHTMAP
sngl		lbl=Disable Dynamic Batching			kw=DISABLE_BATCHING				tt="Disable dynamic batching support for this shader"
sngl		lbl=Enable Meta Pass					kw=ENABLE_META_PASS				tt="Enable meta pass: it is needed to be able to bake lighting but can prevent SRP Batcher compatibility."
sngl		lbl=SRP Batcher Compatibility			kw=ENABLE_SRP_BATCHER			tt="Enable SRP Batcher compatibility: all variables will be declared in the same CBUFFER block for all passes."
dd_end
dd_start	lbl=THIRD PARTY PLUGINS
---
[[MODULE:FEATURES:VertExmotion]]
[[MODULE:FEATURES:CurvedWorld]]
dd_end

#END

#================================================================================================================================================================================================================================================================

#PROPERTIES_NEW
header		Main Properties
/// IF !CUSTOM_ALBEDO
color_rgba	Albedo				fragment, imp(texture, label = "Albedo", variable = "_BaseMap", default = white, tiling_offset = true, global = true)
///
[[MODULE:PROPERTIES_NEW:AlbedoHSV]]
color_rgba	Main Color			fragment, imp(color, label = "Color", variable = "_BaseColor", default = (1,1,1,1)), help = "An adjustable color multiplied with the final albedo color.  Set it to a white color constant if you don't plan on using it, to improve the shader performance."
/// IF !CUSTOM_ALBEDO
float		Alpha				fragment, imp(shader_property_ref, reference = Albedo, swizzle = A), imp(shader_property_ref, reference = Main Color, swizzle = A), help = "The output alpha value, generally only needed when using alpha blending transparency or alpha testing (cutout)",
///
/// IF ALPHA_TESTING
float		Cutoff				fragment, imp(range, label = "Alpha Cutoff", default = 0.5, min = 0, max = 1), help = "The threshold value at which point pixels are discarded when using alpha testing (cutout)"
///
float		Ambient Intensity	lighting, imp(constant, label = "Ambient Intensity", default = 1)

[[MODULE:PROPERTIES_NEW:Ramp Shading LWRP]]
color		Highlight Color		lighting, imp(color, label = "Highlight Color", variable = "_HColor", default = (0.75,0.75,0.75,1))
color		Shadow Color		lighting, imp(color, label = "Shadow Color", variable = "_SColor", default = (0.2,0.2,0.2,1))
[[MODULE:PROPERTIES_NEW:ShadowHSV]]
/// IF CLAMP_LIGHTS_INTENSITY || CLAMP_LIGHTS_INTENSITY_ADD
float3		Max Light Intensity				lighting, imp(constant, default = (1.0, 1.0, 1.0))
///

[[MODULE:PROPERTIES_NEW:Specular]]
[[MODULE:PROPERTIES_NEW:Rim Lighting]]
/// IF GLOSSY_REFLECTIONS
	header		Reflection Probes
	color		Reflection Color			lighting, imp(color, label = "Color", default = (1, 1, 1, 1))
	float		Reflection Smoothness		lighting, imp(range, label = "Smoothness", default = 0.5, min = 0, max = 1)
///
/// IF EMISSION
	header		Emission
	color		Emission									fragment, imp(color, label = "Emission Color", default = (0,0,0,1), hdr = true)
///
/// IF OCCLUSION
	header		Occlusion
	float		Occlusion									lighting, imp(shader_property_ref, reference = Albedo, swizzle = A)
///
[[MODULE:PROPERTIES_NEW:Subsurface Scattering]]
[[MODULE:PROPERTIES_NEW:Reflection]]
[[MODULE:PROPERTIES_NEW:MatCap]]
[[MODULE:PROPERTIES_NEW:Custom Ambient]]
[[MODULE:PROPERTIES_NEW:Normal Mapping]]
[[MODULE:PROPERTIES_NEW:Triplanar]]
[[MODULE:PROPERTIES_NEW:Texture Blending]]
[[MODULE:PROPERTIES_NEW:NdotL Stylization]]
[[MODULE:PROPERTIES_NEW:Sketch]]
[[MODULE:PROPERTIES_NEW:Outline]]
[[MODULE:PROPERTIES_NEW:Dissolve]]
[[MODULE:PROPERTIES_NEW:Wind]]
[[MODULE:PROPERTIES_NEW:Vertical Fog]]
/// IF PASS_SILHOUETTE
		header			Silhouette Pass
		color_rgba		Silhouette Color				lighting, imp(color, label = "Silhouette Color", default = (0,0,0,0.33))
	/// IF SILHOUETTE_STENCIL
		fixed_function_float	Silhouette Stencil Reference	fixed, imp(constant, label = "Silhouette Stencil Reference", default = 1)
	///
		fixed_function_enum		Silhouette Blend Source			fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.BlendFactor, default = "SrcAlpha")
		fixed_function_enum		Silhouette Blend Destination	fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.BlendFactor, default = "OneMinusSrcAlpha")
///
/// IF CUSTOM_BLENDING || BLEND_OP
header					Blending
///
/// IF CUSTOM_BLENDING
fixed_function_enum		Blend Source					fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.BlendFactor, default = "SrcAlpha")
fixed_function_enum		Blend Destination				fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.BlendFactor, default = "OneMinusSrcAlpha")
///
/// IF BLEND_OP
fixed_function_enum		Blend Operation					fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.BlendOperation, default = "Add")
///
/// IF ZWRITE || ZTEST || CULLING
header		Shader States
///
/// IF ZWRITE
fixed_function_enum		Depth Write						fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.DepthWrite, default = "On")
///
/// IF ZTEST
fixed_function_enum		Depth Test						fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.CompareFunction, default = "LEqual")
///
/// IF CULLING
fixed_function_enum		Face Culling					fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.Culling, default = "Back")
///
/// IF STENCIL
		header	Stencil
		fixed_function_float		Stencil Reference	fixed, imp(constant, label = "Reference", default = 0)
		fixed_function_float		Stencil Read Mask	fixed, imp(constant, label = "Read Mask", default = 255)
		fixed_function_float		Stencil Write Mask	fixed, imp(constant, label = "Write Mask", default = 255)
	/// IF !STENCIL_DOUBLE_SIDED
		fixed_function_enum			Stencil Comparison	fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.CompareFunction, default = "Always")
		fixed_function_enum			Stencil Pass		fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
		fixed_function_enum			Stencil Fail		fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
		fixed_function_enum			Stencil Depth Fail	fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
	/// ELSE
		fixed_function_enum			Stencil Front Comparison	fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.CompareFunction, default = "Always")
		fixed_function_enum			Stencil Front Pass			fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
		fixed_function_enum			Stencil Front Fail			fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
		fixed_function_enum			Stencil Front Depth Fail	fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")

		fixed_function_enum			Stencil Back Comparison		fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.CompareFunction, default = "Always")
		fixed_function_enum			Stencil Back Pass			fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
		fixed_function_enum			Stencil Back Fail			fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
		fixed_function_enum			Stencil Back Depth Fail		fixed, imp(enum, enum_type = ToonyColorsPro.ShaderGenerator.StencilOperation, default = "Keep")
	///
///
header	Third Party
[[MODULE:PROPERTIES_NEW:VertExmotion]]
[[MODULE:PROPERTIES_NEW:CurvedWorld]]
header			Hooks					"Hooks are special Shader Properties that expose variables from the shader code that can then be freely modified"
float3			Vertex Position			vertex, label = "Vertex Position (Object Space)", imp(hook, label = "input.vertex.xyz", toggles = HOOK_VERTEX_POSITION), help = "The object-space vertex position, e.g. to make your own vertex displacement function."
float3			Vertex Position World	vertex, label = "Vertex Position (World Space)", imp(hook, label = "worldPos.xyz", toggles = HOOK_VERTEX_POSITION_WORLD), help = "The world-space vertex position."
float3			Main Light Direction			lighting, label = "Main Light Direction", imp(hook, label = "lightDir", toggles = HOOK_MAIN_LIGHT_DIR), help = "The direction of the main directional light."
float3			Additional Lights Direction		lighting, label = "Additional Lights Direction", imp(hook, label = "lightDir", toggles = HOOK_OTHER_LIGHTS_DIR), help = "The direction of additional lights."
color			Main Light Color				lighting, label = "Main Light Color", imp(hook, label = "lightColor", toggles = HOOK_MAIN_LIGHT_COLOR), help = "The color of the main directional light."
color			Additional Lights Color			lighting, label = "Additional Lights Color", imp(hook, label = "lightColor", toggles = HOOK_OTHER_LIGHTS_COLOR), help = "The color of additional lights."
color			Shading Ramp					lighting, label = "Shading Ramp", imp(hook, label = "ramp", toggles = HOOK_RAMP), help = "The colored ramp calculated, depending on the ramp settings, with the highlight and shadow colors."
color			Main Light Attenuation			lighting, label = "Main Light Attenuation", imp(hook, label = "atten", toggles = HOOK_MAIN_LIGHT_ATTEN), help = "The attenuation of the main directional light (shadow map)."
color			Additional Lights Attenuation	lighting, label = "Additional Lights Attenuation", imp(hook, label = "atten", toggles = HOOK_OTHER_LIGHTS_ATTEN), help = "The color of additional lights (shadow map and distance attenuation)."
color			Final Albedo			fragment, imp(hook, label = "albedo.rgb", toggles = HOOK_FINAL_ALBEDO), help = "The final albedo used by the shader before lighting."
color			Final Ambient			fragment, imp(hook, label = "indirectDiffuse.rgb", toggles = HOOK_FINAL_AMBIENT), help = "The final ambient color used by the shader, with any modifiers applied (e.g. Occlusion)"
color			Final Color				fragment, imp(hook, label = "color.rgb", toggles = HOOK_FINAL_COLOR), help = "The final color returned by the shader, after having processed all lighting and effects."
header		Misc
/// IF USE_NDV_MIN_MAX_VERT
	float			NDV Min Vert		fragment, imp(range, label = "NDV Min (Vertex)", default = 0.5, min = 0, max = 2)
	float			NDV Max Vert		fragment, imp(range, label = "NDV Max (Vertex)", default = 1.0, min = 0, max = 2)
///
/// IF USE_NDV_MIN_MAX_FRAG
	float			NDV Min Frag		fragment, imp(range, label = "NDV Min", default = 0.5, min = 0, max = 2)
	float			NDV Max Frag		fragment, imp(range, label = "NDV Max", default = 1.0, min = 0, max = 2)
///
#END

#================================================================================================================================================================================================================================================================

#KEYWORDS

# SRP feature
feature_on		LWRP

# features
/// IF GLOSSY_REFLECTIONS
	feature_on		USE_VIEW_DIRECTION_FRAGMENT
///

/// IF USE_NDV_VERTEX
	feature_on		USE_WORLD_NORMAL_VERTEX
	feature_on		USE_VIEW_DIRECTION_VERTEX
///

/// IF USE_NDV_FRAGMENT
	feature_on		USE_WORLD_NORMAL_FRAGMENT
	feature_on		USE_VIEW_DIRECTION_FRAGMENT
	feature_on		USE_WORLD_POSITION_FRAGMENT
///

/// IF BACKFACE_LIGHTING_Z || BACKFACE_LIGHTING_XYZ
	feature_on		USE_VFACE
///

/// IF USE_VIEW_DIRECTION_FRAGMENT
	feature_on		USE_WORLD_POSITION_FRAGMENT
///

/// IF HOOK_VERTEX_POSITION_WORLD
	feature_on		APPLY_WORLD_POSITION
///

# queue
/// IF SHADER_BLENDING || OUTLINE_BLENDING
	feature_on		QUEUE_TRANSPARENT
///
/// IF ALPHA_TESTING
	feature_on		QUEUE_ALPHATEST
///

# rendertype
/// IF CURVED_WORLD
	/// IF ALPHA_TESTING
		set_keyword		RENDER_TYPE		CurvedWorld_TransparentCutout
	/// ELSE
		set_keyword		RENDER_TYPE		CurvedWorld_Opaque
	///
/// ELSE
	/// IF ALPHA_TESTING
		set_keyword		RENDER_TYPE		TransparentCutout
	/// ELSE
		set_keyword		RENDER_TYPE		Opaque
	///
///

[[MODULE:KEYWORDS]]

#END

#================================================================================================================================================================================================================================================================

Shader "@%SHADER_NAME%@"
{
	Properties
	{
		[TCP2HeaderHelp(Base)]
		[[PROP:Main Color]]
		[[PROP:Highlight Color]]
		[[PROP:Shadow Color]]
		[[MODULE:PROPERTIES_BLOCK:ShadowHSV]]
/// IF !CUSTOM_ALBEDO
		[[PROP:Albedo]]
		[[PROP:Alpha]]
///
		[[MODULE:PROPERTIES_BLOCK:AlbedoHSV]]
/// IF ALPHA_TESTING
		[[PROP:Cutoff]]
///
/// IF OCCLUSION
		[[PROP:Occlusion]]
///
		[TCP2Separator]

		[[MODULE:PROPERTIES_BLOCK:Ramp Shading LWRP]]
		[[MODULE:PROPERTIES_BLOCK:Specular]]
/// IF EMISSION

		[TCP2HeaderHelp(Emission)]
		[[PROP:Emission]]
		[TCP2Separator]
///
		[[MODULE:PROPERTIES_BLOCK:Rim Lighting]]
/// IF (GLOSSY_REFLECTIONS || REFLECTION_CUBEMAP)

		[TCP2HeaderHelp(Reflections)]
	/// IF REFLECTION_SHADER_FEATURE
		[Toggle(TCP2_REFLECTIONS)] _UseReflections ("Enable Reflections", Float) = 0
	///
///
/// IF GLOSSY_REFLECTIONS
		[[PROP:Reflection Color]]
		[[PROP:Reflection Smoothness]]
///
		[[MODULE:PROPERTIES_BLOCK:Reflection]]
/// IF (GLOSSY_REFLECTIONS || REFLECTION_CUBEMAP)
		[TCP2Separator]
///
		[[MODULE:PROPERTIES_BLOCK:Subsurface Scattering]]
		[[MODULE:PROPERTIES_BLOCK:MatCap]]
	#if_not_empty
		[Header(Ambient Lighting)]
	#start_not_empty_block
/// IF AMBIENT_SHADER_FEATURE
		[Toggle(TCP2_AMBIENT)] _UseAmbient ("Enable Ambient/Indirect Diffuse", Float) = 0
///
		[[PROP:Ambient Intensity]]
		[[MODULE:PROPERTIES_BLOCK:Custom Ambient]]
	#end_not_empty_block
		[TCP2Separator]
	#end_not_empty
		[[MODULE:PROPERTIES_BLOCK:Triplanar]]
		[[MODULE:PROPERTIES_BLOCK:Normal Mapping]]
		[[MODULE:PROPERTIES_BLOCK:Texture Blending]]
		[[MODULE:PROPERTIES_BLOCK:NdotL Stylization]]
		[[MODULE:PROPERTIES_BLOCK:Sketch]]
		[[MODULE:PROPERTIES_BLOCK:Wind]]
		[[MODULE:PROPERTIES_BLOCK:Dissolve]]
		[[MODULE:PROPERTIES_BLOCK:Vertical Fog]]
/// IF PASS_SILHOUETTE
		[TCP2HeaderHelp(Silhouette Pass)]
		[[PROP:Silhouette Color]]
		[[PROP:Silhouette Blend Source]]
		[[PROP:Silhouette Blend Destination]]
		[TCP2Separator]
///
		[[MODULE:PROPERTIES_BLOCK:Outline]]
		[[MODULE:PROPERTIES_BLOCK:NoTile Sampling]]
/// IF USE_NDV_MIN_MAX_VERT
		[[PROP:NDV Min Vert]]
		[[PROP:NDV Max Vert]]
		[TCP2Separator]
///
/// IF USE_NDV_MIN_MAX_FRAG
		[[PROP:NDV Min Frag]]
		[[PROP:NDV Max Frag]]
		[TCP2Separator]
///
	#if_not_empty
	#start_not_empty_block
		[[PROP:Vertex Position]]
		[[PROP:Final Color]]
	#end_not_empty_block
		[TCP2Separator]
	#end_not_empty
/// IF STENCIL
		[TCP2HeaderHelp(Stencil)]
		[[PROP:Stencil Reference]]
		[[PROP:Stencil Read Mask]]
		[[PROP:Stencil Write Mask]]
	/// IF !STENCIL_DOUBLE_SIDED
		[[PROP:Stencil Comparison]]
		[[PROP:Stencil Pass]]
		[[PROP:Stencil Fail]]
		[[PROP:Stencil Depth Fail]]
	/// ELSE
		[[PROP:Stencil Front Comparison]]
		[[PROP:Stencil Front Pass]]
		[[PROP:Stencil Front Fail]]
		[[PROP:Stencil Front Depth Fail]]
		[[PROP:Stencil Back Comparison]]
		[[PROP:Stencil Back Pass]]
		[[PROP:Stencil Back Fail]]
		[[PROP:Stencil Back Depth Fail]]
	///
		[TCP2Separator]
///
		[[PROPERTIES]]

/// IF !DISABLE_SHADOW_RECEIVING
		[ToggleOff(_RECEIVE_SHADOWS_OFF)] _ReceiveShadowsOff ("Receive Shadows", Float) = 1

///
		//Avoid compile error if the properties are ending with a drawer
		[HideInInspector] __dummy__ ("unused", Float) = 0
	}

	SubShader
	{
		Tags
		{
/// IF DISABLE_BATCHING
			"DisableBatching" = "True"
///
			"RenderPipeline" = "UniversalPipeline"
# Queues are ordered from highest to lowest in terms of priority
/// IF QUEUE_TRANSPARENT
			"RenderType"="Transparent"
			"Queue"="Transparent"
			"IgnoreProjectors"="True"
/// ELIF QUEUE_ALPHATEST
			"RenderType"="@%RENDER_TYPE%@"
			"Queue"="AlphaTest"
/// ELIF PASS_SILHOUETTE
			"RenderType"="@%RENDER_TYPE%@"
			"Queue"="Geometry+10" //Make sure that the objects are rendered later to avoid sorting issues with the transparent silhouette
/// ELSE
			"RenderType"="@%RENDER_TYPE%@"
///
		}

		HLSLINCLUDE
		#define fixed half
		#define fixed2 half2
		#define fixed3 half3
		#define fixed4 half4

		#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
		
#		[[MODULE:FUNCTIONS:Screen Space UV]]
#		[[MODULE:FUNCTIONS:HSV]]
#		[[MODULE:FUNCTIONS:Hash Functions]]
#		[[MODULE:FUNCTIONS:NoTile Sampling]]
#		[[MODULE:FUNCTIONS:VertExmotion]]
#		[[MODULE:FUNCTIONS:CurvedWorld]]
#		[[MODULE:FUNCTIONS:Outline]]

/// IF ENABLE_SRP_BATCHER

		// Uniforms
		CBUFFER_START(UnityPerMaterial)
			[[VARIABLES_INCLUDE]]
			[[MODULE:VARIABLES]]
		CBUFFER_END

		[[VARIABLES_GPU_INSTANCING_INCLUDE]]

///

		[[MODULE:FUNCTIONS]]

		ENDHLSL

#PASS
/// IF OUTLINE

		// Outline Include
		HLSLINCLUDE
		
/// IF FOG
		#pragma multi_compile_fog
///

	/// IF !ENABLE_SRP_BATCHER
		[[VARIABLES_INCLUDE]]
		[[VARIABLES_GPU_INSTANCING]]
	///

		struct appdata_outline
		{
			float4 vertex : POSITION;
			float3 normal : NORMAL;
			[[VERTEX_INPUT_TEXCOORDS]]
			[[VERTEX_INPUT_OUTLINE]]
	/// IF USE_VERTEX_COLORS_VERT
			fixed4 vertexColor : COLOR;
	/// ELSE
		#if TCP2_COLORS_AS_NORMALS
			float4 vertexColor : COLOR;
		#endif
	///
	/// IF !USE_TANGENT_VERT && !USE_TANGENT_FRAGMENT && !VERTEXMOTION_NORMAL && !CURVED_WORLD_NORMAL
		#if TCP2_TANGENT_AS_NORMALS
	///
			float4 tangent : TANGENT;
	/// IF !USE_TANGENT_VERT && !USE_TANGENT_FRAGMENT && !VERTEXMOTION_NORMAL && !CURVED_WORLD_NORMAL
		#endif
	///
			UNITY_VERTEX_INPUT_INSTANCE_ID
		};

		struct v2f_outline
		{
			float4 vertex : SV_POSITION;
			[[INPUT_STRUCT_SEMANTICS:0]]
#INPUT_VARIABLES
	/// IF USE_VERTEX_COLORS_FRAG
			fixed4 vertexColor;
	///
	/// IF USE_SCREEN_POSITION_FRAGMENT
			float4 screenPosition;
	///
	/// IF FOG
			float fogFactor;
	///
	/// IF USE_WORLD_POSITION_FRAGMENT
			float3 worldPos;
	///
			[[MODULE:INPUT:Outline]]
#END
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
		};

#INPUT = v
#OUTPUT = output
#VERTEX
		v2f_outline vertex_outline (appdata_outline v)
		{
			v2f_outline output = (v2f_outline)0;

			UNITY_SETUP_INSTANCE_ID(v);
			UNITY_TRANSFER_INSTANCE_ID(v, output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

	/// IF USE_WORLD_POSITION_UV_VERTEX
			float3 worldPosUv = mul(unity_ObjectToWorld, v.vertex).xyz;
	///
			[[VERTEX_TEXCOORDS]]
			[[SAMPLE_CUSTOM_PROPERTIES]]
			[[SAMPLE_SHADER_PROPERTIES]]

			[[MODULE:VERTEX:VertExmotion:LWRP(v.vertex, v.normal, v.tangent.xyz)]]
			[[MODULE:VERTEX:CurvedWorld(v.vertex, v.normal, v.tangent)]]

	/// IF HOOK_VERTEX_POSITION
			v.vertex.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position]];
	///
			float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	/// IF HOOK_VERTEX_POSITION_WORLD
			worldPos.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position World]];
	///
			[[MODULE:VERTEX:Wind(worldPos.xyz)]]
	/// IF APPLY_WORLD_POSITION
			v.vertex.xyz = mul(unity_WorldToObject, float4(worldPos, 1)).xyz;
	///
	/// IF USE_WORLD_POSITION_FRAGMENT
			output.[[INPUT_VALUE:worldPos]] = worldPos;
	///
	/// IF USE_VERTEX_COLORS_FRAG
			output.vertexColor = v.vertexColor;
	///
			[[MODULE:VERTEX:Screen Space UV(screenPos, clipPos, output)]]
		[[MODULE:VERTEX:Outline(v, output, null)]]
	/// IF USE_CLIP_POSITION_VERTEX || USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX
			float4 clipPos = output.vertex;
	///
	/// IF USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX

			//Screen Position
			float4 screenPos = ComputeScreenPos(clipPos);
		/// IF USE_SCREEN_POSITION_FRAGMENT
			output.screenPosition = screenPos;
		///
	///
	/// IF FOG
			output.[[INPUT_VALUE:fogFactor]] = ComputeFogFactor(output.vertex.z);
	///
			return output;
		}

#INPUT = input
#OUTPUT = no_output
#FRAGMENT
		float4 fragment_outline (v2f_outline input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);

			[[MODULE:FRAGMENT:Screen Space UV(input.screenPosition, input)]]
			[[SAMPLE_CUSTOM_PROPERTIES]]
			[[SAMPLE_SHADER_PROPERTIES]]
			[[MODULE:FRAGMENT:Outline(input)]]
	/// IF FOG
			outlineColor.rgb = MixFog(outlineColor.rgb, input.[[INPUT_VALUE:fogFactor]]);
	///
			[[MODULE:FRAGMENT:Vertical Fog(outlineColor.rgb, input.[[INPUT_VALUE:worldPos]])]]
			return outlineColor;
		}

		ENDHLSL
		// Outline Include End
///
#PASS
/// IF PASS_SILHOUETTE
		//Silhouette Pass
		Pass
		{
			Name "Silhouette"
	/// IF SILHOUETTE_URP_FEATURE
			Tags { "LightMode" = "Silhouette" }
	///
			Blend [[VALUE:Silhouette Blend Source]] [[VALUE:Silhouette Blend Destination]]
			ZTest Greater
			ZWrite Off
	/// IF SILHOUETTE_STENCIL

			Stencil
			{
				Ref [[VALUE:Silhouette Stencil Reference]]
				Comp NotEqual
				Pass Replace
				ReadMask [[VALUE:Silhouette Stencil Reference]]
				WriteMask [[VALUE:Silhouette Stencil Reference]]
			}
	///

			HLSLPROGRAM
			#pragma vertex vertex_silhouette
			#pragma fragment fragment_silhouette
			#pragma target @%SHADER_TARGET%@

			struct appdata_sil
			{
				float4 vertex : POSITION;
				[[VERTEX_INPUT_TEXCOORDS]]
	/// IF USE_VERTEX_COLORS_VERT
				fixed4 vertexColor : COLOR;
	///
	/// IF VERTEXMOTION_NORMAL || CURVED_WORLD_NORMAL
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
	///
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};

			struct v2f_sil
			{
				float4 vertex : SV_POSITION;
				[[INPUT_STRUCT_SEMANTICS:0]]
#INPUT_VARIABLES
	/// IF USE_VERTEX_COLORS_FRAG
				fixed4 vertexColor;
	///
	/// IF USE_SCREEN_POSITION_FRAGMENT
				float4 screenPosition;
	///
				[[MODULE:INPUT]]
#END
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};

/// IF !ENABLE_SRP_BATCHER
			[[VARIABLES]]
			[[VARIABLES_GPU_INSTANCING]]
///

#INPUT = v
#OUTPUT = output
#VERTEX
			v2f_sil vertex_silhouette (appdata_sil v)
			{
				v2f_sil output = (v2f_sil)0;

				UNITY_SETUP_INSTANCE_ID(v);
				UNITY_TRANSFER_INSTANCE_ID(v, output);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

/// IF USE_WORLD_POSITION_UV_VERTEX
				float3 worldPosUv = mul(unity_ObjectToWorld, v.vertex).xyz;
///
				[[VERTEX_TEXCOORDS]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]

				[[MODULE:VERTEX:VertExmotion:LWRP(v.vertex, v.normal, v.tangent.xyz)]]
				[[MODULE:VERTEX:CurvedWorld(v.vertex, v.normal, v.tangent)]]

	/// IF HOOK_VERTEX_POSITION
				v.vertex.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position]];
	///
				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	/// IF HOOK_VERTEX_POSITION_WORLD
				worldPos.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position World]];
	///
				[[MODULE:VERTEX:Wind(worldPos.xyz)]]
	/// IF APPLY_WORLD_POSITION
				v.vertex.xyz = mul(unity_WorldToObject, float4(worldPos, 1)).xyz;
	///
				output.vertex = TransformObjectToHClip(v.vertex.xyz);
	/// IF USE_VERTEX_COLORS_FRAG
				output.vertexColor = v.vertexColor;
	///
	/// IF USE_CLIP_POSITION_VERTEX || USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX
				float4 clipPos = output.vertex;
	///
	/// IF USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX

				//Screen Position
				float4 screenPos = ComputeScreenPos(clipPos);
		/// IF USE_SCREEN_POSITION_FRAGMENT
				output.screenPosition = screenPos;
		///
	///
				[[MODULE:VERTEX:Screen Space UV(screenPos, clipPos, output)]]
				return output;
			}

#INPUT = input
#OUTPUT = no_output
#FRAGMENT
			half4 fragment_silhouette (v2f_sil input) : SV_Target
			{
				UNITY_SETUP_INSTANCE_ID(input);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);

				[[MODULE:FRAGMENT:Screen Space UV(input.screenPosition, input)]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]
				return [[VALUE:Silhouette Color]];
			}
			ENDHLSL
		}

///
#PASS
/// IF DEPTH_PREPASS && ___DISABLED___

		//Depth pre-pass
		Pass
		{
			Name "Depth Prepass"
			ColorMask 0
			ZWrite On

			CGPROGRAM
			#pragma vertex vertex_depthprepass
			#pragma fragment fragment_depthprepass
			#pragma target @%SHADER_TARGET%@

			#include "UnityCG.cginc"
			#include "UnityLightingCommon.cginc"	// needed for LightColor

			struct appdata_sil
			{
				float4 vertex : POSITION;
				[[VERTEX_INPUT_TEXCOORDS]]
	/// IF USE_VERTEX_COLORS_VERT
				fixed4 vertexColor : COLOR;
	///
	/// IF VERTEXMOTION_NORMAL || CURVED_WORLD_NORMAL
				float3 normal : NORMAL;
				float4 tangent : TANGENT;
	///
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};

			struct v2f_depthprepass
			{
				float4 vertex : SV_POSITION;
				UNITY_VERTEX_OUTPUT_STEREO
				[[INPUT_STRUCT_SEMANTICS:0]]
#INPUT_VARIABLES
	/// IF USE_VERTEX_COLORS_FRAG
				fixed4 vertexColor;
	///
	/// IF USE_SCREEN_POSITION_FRAGMENT
				float4 screenPosition;
	///
				[[MODULE:INPUT]]
#END
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};

/// IF !ENABLE_SRP_BATCHER
			[[VARIABLES]]
			[[VARIABLES_GPU_INSTANCING]]
///

#INPUT = v
#OUTPUT = output
#VERTEX
			v2f_depthprepass vertex_depthprepass (appdata_sil v)
			{
				v2f_depthprepass output;
				UNITY_INITIALIZE_OUTPUT(v2f_depthprepass, output);

				UNITY_SETUP_INSTANCE_ID(v);
				UNITY_TRANSFER_INSTANCE_ID(v, output);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

/// IF USE_WORLD_POSITION_UV_VERTEX
				float3 worldPosUv = mul(unity_ObjectToWorld, v.vertex).xyz;
///
				[[VERTEX_TEXCOORDS]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]

				[[MODULE:VERTEX:VertExmotion(v.vertex, v.normal, v.tangent)]]
				[[MODULE:VERTEX:CurvedWorld(v.vertex, v.normal, v.tangent)]]

	/// IF HOOK_VERTEX_POSITION
				v.vertex.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position]];
	///
				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	/// IF HOOK_VERTEX_POSITION_WORLD
				worldPos.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position World]];
	///
				[[MODULE:VERTEX:Wind(worldPos.xyz)]]
	/// IF APPLY_WORLD_POSITION
				v.vertex.xyz = mul(unity_WorldToObject, float4(worldPos, 1)).xyz;
	///
				output.vertex = UnityObjectToClipPos(v.vertex);
	/// IF USE_VERTEX_COLORS_FRAG
				output.vertexColor = v.vertexColor;
	///
	/// IF USE_CLIP_POSITION_VERTEX || USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX
				float4 clipPos = output.vertex;
	///
	/// IF USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX

				//Screen Position
				float4 screenPos = ComputeScreenPos(clipPos);
		/// IF USE_SCREEN_POSITION_FRAGMENT
				output.screenPosition = screenPos;
		///
	///
				[[MODULE:VERTEX:Screen Space UV(screenPos, clipPos, output)]]
				return output;
			}

#INPUT = input
#OUTPUT = no_output
#FRAGMENT
			half4 fragment_depthprepass (v2f_depthprepass input) : SV_Target
			{
				UNITY_SETUP_INSTANCE_ID(input);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);

				[[MODULE:FRAGMENT:Screen Space UV(input.screenPosition, input)]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]
				return 0;
			}
			ENDCG
		}
///
/// IF OUTLINE && OUTLINE_BEHIND_STENCIL

		Stencil
		{
			Ref [[VALUE:Outline Stencil Reference]]
			Comp Always
			Pass Replace
		}
///
#PASS
		Pass
		{
			Name "Main"
			Tags { "LightMode"="UniversalForward" }
/// IF ALPHA_BLENDING
			Blend SrcAlpha OneMinusSrcAlpha
/// ELIF ALPHA_BLENDING_PREMULT
			Blend One OneMinusSrcAlpha
/// ELIF ADDITIVE_BLENDING
			Blend One One
/// ELIF MULTIPLICATIVE_BLENDING
			Blend DstColor Zero
/// ELIF CUSTOM_BLENDING
			Blend [[VALUE:Blend Source]] [[VALUE:Blend Destination]]
///
/// IF BLEND_OP
			BlendOp [[VALUE:Blend Operation]]
///
/// IF ALPHA_TESTING && ALPHA_TO_COVERAGE
			AlphaToMask On
///
/// IF ZWRITE
			ZWrite [[VALUE:Depth Write]]
///
/// IF ZTEST
			ZTest [[VALUE:Depth Test]]
///
/// IF CULLING
			Cull [[VALUE:Face Culling]]
///
/// IF STENCIL

			Stencil
			{
				Ref [[VALUE:Stencil Reference]]
				ReadMask [[VALUE:Stencil Read Mask]]
				WriteMask [[VALUE:Stencil Write Mask]]
	/// IF !STENCIL_DOUBLE_SIDED
				Comp [[VALUE:Stencil Comparison]]
				Pass [[VALUE:Stencil Pass]]
				Fail [[VALUE:Stencil Fail]]
				ZFail [[VALUE:Stencil Depth Fail]]
	/// ELSE
				CompFront [[VALUE:Stencil Front Comparison]]
				PassFront [[VALUE:Stencil Front Pass]]
				FailFront [[VALUE:Stencil Front Fail]]
				ZFailFront [[VALUE:Stencil Front Depth Fail]]

				CompBack [[VALUE:Stencil Back Comparison]]
				PassBack [[VALUE:Stencil Back Pass]]
				FailBack [[VALUE:Stencil Back Fail]]
				ZFailBack [[VALUE:Stencil Back Depth Fail]]
	///
			}
/// ELIF PASS_SILHOUETTE && SILHOUETTE_STENCIL

			// Stencil value used for Silhouette Pass to make sure we don't see a
			// silhouette when the same mesh occludes parts of itself
			Stencil
			{
				Ref [[VALUE:Silhouette Stencil Reference]]
				Pass Replace
				ReadMask [[VALUE:Silhouette Stencil Reference]]
				WriteMask [[VALUE:Silhouette Stencil Reference]]
			}
///

			HLSLPROGRAM
			// Required to compile gles 2.0 with standard SRP library
			// All shaders must be compiled with HLSLcc and currently only gles is not using HLSLcc by default
			#pragma prefer_hlslcc gles
			#pragma exclude_renderers d3d11_9x
			#pragma target @%SHADER_TARGET%@

			// -------------------------------------
			// Material keywords
			//#pragma shader_feature _ALPHATEST_ON
/// IF DISABLE_SHADOW_RECEIVING
			#pragma multi_compile _RECEIVE_SHADOWS_OFF
/// ELSE
			#pragma shader_feature _ _RECEIVE_SHADOWS_OFF
///

			// -------------------------------------
			// Universal Render Pipeline keywords
			#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
			#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
			#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
			#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
			#pragma multi_compile _ _SHADOWS_SOFT
			#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE

			// -------------------------------------
/// IF ENABLE_LIGHTMAP
			#pragma multi_compile _ DIRLIGHTMAP_COMBINED
			#pragma multi_compile _ LIGHTMAP_ON
///
/// IF FOG
			#pragma multi_compile_fog
///

			//--------------------------------------
			// GPU Instancing
			#pragma multi_compile_instancing

			#pragma vertex Vertex
			#pragma fragment Fragment

	#if_not_empty
			//--------------------------------------
			// Toony Colors Pro 2 keywords
	#start_not_empty_block
			[[MODULE:SHADER_FEATURES_BLOCK:Specular]]
			[[MODULE:SHADER_FEATURES_BLOCK:Rim Lighting]]
/// IF (GLOSSY_REFLECTIONS || REFLECTION_CUBEMAP) && REFLECTION_SHADER_FEATURE
			#pragma shader_feature TCP2_REFLECTIONS
///
/// IF AMBIENT_SHADER_FEATURE
			#pragma shader_feature TCP2_AMBIENT
///
			[[MODULE:SHADER_FEATURES_BLOCK:MatCap]]
			[[MODULE:SHADER_FEATURES_BLOCK:Subsurface Scattering]]
			[[MODULE:SHADER_FEATURES_BLOCK:Normal Mapping]]
			[[MODULE:SHADER_FEATURES_BLOCK:Sketch]]
			[[MODULE:SHADER_FEATURES_BLOCK:NdotL Stylization]]
			[[MODULE:SHADER_FEATURES_BLOCK:Wind]]
			[[MODULE:SHADER_FEATURES_BLOCK:Dissolve]]
			[[MODULE:SHADER_FEATURES_BLOCK:Vertical Fog]]
	#end_not_empty_block
	#end_not_empty

/// IF !ENABLE_SRP_BATCHER
			// Uniforms
			CBUFFER_START(UnityPerMaterial)
			[[VARIABLES]]
			[[MODULE:VARIABLES]]
			CBUFFER_END
			[[VARIABLES_GPU_INSTANCING]]
///

			// vertex input
			struct Attributes
			{
				float4 vertex       : POSITION;
				float3 normal       : NORMAL;
				float4 tangent      : TANGENT;
/// IF ENABLE_LIGHTMAP
				float2 uvLM         : TEXCOORD1;
///
/// IF USE_VERTEX_COLORS_VERT
				half4 vertexColor   : COLOR;
///
				[[VERTEX_INPUT_TEXCOORDS]]
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};

			// vertex output / fragment input
			struct Varyings
			{
				float4 positionCS     : SV_POSITION;
				float3 normal         : NORMAL;
				float4 worldPosAndFog : TEXCOORD0;
			#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)
				float4 shadowCoord    : TEXCOORD1; // compute shadow coord per-vertex for the main light
			#endif
			#ifdef _ADDITIONAL_LIGHTS_VERTEX
				half3 vertexLights : TEXCOORD2;
			#endif
				[[INPUT_STRUCT_SEMANTICS:3]]
#INPUT_VARIABLES
/// IF USE_OBJECT_POSITION_FRAGMENT
				float3 objPos;
///
/// IF USE_OBJECT_NORMAL_FRAGMENT
				float3 objNormal;
///
/// IF USE_VERTEX_COLORS_FRAG
				half4 vertexColor;
///
/// IF USE_TANGENT_FRAGMENT
				float3 tangent;
///
/// IF USE_BITANGENT_FRAGMENT
				float3 bitangent;
///
/// IF USE_SCREEN_POSITION_FRAGMENT
				float4 screenPosition;
///
/// IF FOG
				float fogFactor;
///
/// IF ENABLE_LIGHTMAP
				float2 uvLM;
///
				[[MODULE:INPUT]]
#END
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};

#VERTEX, INPUT = input, OUTPUT = output
			Varyings Vertex(Attributes input)
			{
				Varyings output = (Varyings)0;

				UNITY_SETUP_INSTANCE_ID(input);
				UNITY_TRANSFER_INSTANCE_ID(input, output);
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

/// IF USE_WORLD_POSITION_UV_VERTEX
				float3 worldPosUv = mul(unity_ObjectToWorld, input.vertex).xyz;
///
				[[VERTEX_TEXCOORDS]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]
/// IF ENABLE_LIGHTMAP
				output.[[INPUT_VALUE:uvLM]] = input.uvLM.xy * unity_LightmapST.xy + unity_LightmapST.zw;
///

				[[MODULE:VERTEX:VertExmotion:LWRP(input.vertex, input.normal, input.tangent.xyz)]]
				[[MODULE:VERTEX:CurvedWorld(input.vertex, input.normal, input.tangent)]]
/// IF HOOK_VERTEX_POSITION
				input.vertex.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position]];
///
				float3 worldPos = mul(unity_ObjectToWorld, input.vertex).xyz;
/// IF HOOK_VERTEX_POSITION_WORLD
				worldPos.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position World]];
///
				[[MODULE:VERTEX:Wind(worldPos.xyz)]]
/// IF APPLY_WORLD_POSITION
				input.vertex.xyz = mul(unity_WorldToObject, float4(worldPos, 1)).xyz;
///
/// IF USE_OBJECT_POSITION_FRAGMENT
				output.[[INPUT_VALUE:objPos]] = input.vertex.xyz;
///
/// IF USE_OBJECT_NORMAL_FRAGMENT
				output.[[INPUT_VALUE:objNormal]] = input.normal.xyz;
///
				VertexPositionInputs vertexInput = GetVertexPositionInputs(input.vertex.xyz);
			#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)
				output.shadowCoord = GetShadowCoord(vertexInput);
			#endif
/// IF USE_CLIP_POSITION_VERTEX || USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX
				float4 clipPos = vertexInput.positionCS;
///
/// IF USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX

				float4 screenPos = ComputeScreenPos(clipPos);
	/// IF USE_SCREEN_POSITION_FRAGMENT
				output.[[INPUT_VALUE:screenPosition]] = screenPos;
	///
///
				[[MODULE:VERTEX:Screen Space UV(screenPos, clipPos, output)]]

/// IF USE_TANGENT_VERT || USE_TANGENT_FRAGMENT
				VertexNormalInputs vertexNormalInput = GetVertexNormalInputs(input.normal, input.tangent);
/// ELSE
				VertexNormalInputs vertexNormalInput = GetVertexNormalInputs(input.normal);
///
			#ifdef _ADDITIONAL_LIGHTS_VERTEX
				// Vertex lighting
				output.vertexLights = VertexLighting(vertexInput.positionWS, vertexNormalInput.normalWS);
			#endif

				// world position
				output.worldPosAndFog = float4(vertexInput.positionWS.xyz, 0);
/// IF FOG

				// Computes fog factor per-vertex
				output.worldPosAndFog.w = ComputeFogFactor(vertexInput.positionCS.z);
///

				// normal
				output.normal = NormalizeNormalPerVertex(vertexNormalInput.normalWS);
/// IF USE_TANGENT_FRAGMENT

				// tangent
				output.[[INPUT_VALUE:tangent]] = vertexNormalInput.tangentWS;
///
/// IF USE_BITANGENT_FRAGMENT
				output.[[INPUT_VALUE:bitangent]] = vertexNormalInput.bitangentWS;
///

				// clip position
				output.positionCS = vertexInput.positionCS;

/// IF USE_VERTEX_COLORS_FRAG
				output.vertexColor = input.vertexColor;
///
/// IF USE_VIEW_DIRECTION_VERTEX
				half3 viewDirWS = SafeNormalize(GetCameraPositionWS() - vertexInput.positionWS);
///
#ENABLE_IMPL: float ndv, lbl = "Special/N·V (Vertex)", help = "The dot product between the normal and view direction.", toggles = "USE_NDV_VERTEX", options = "(Use Min/Max Properties,USE_NDV_MIN_MAX_VERT,config),(Invert,USE_NDV_INVERT_VERT)"
/// IF USE_NDV_VERTEX
				half ndv = max(0, dot(viewDirWS, vertexNormalInput.normalWS));
				half ndvRaw = ndv;
	/// IF USE_NDV_INVERT_VERT
				ndv = 1 - ndv;
	///
	/// IF USE_NDV_MIN_MAX_VERT
				ndv = smoothstep([[VALUE:NDV Min Vert]], [[VALUE:NDV Max Vert]], ndv);
	///
///

				[[MODULE:VERTEX:Rim Lighting(ndvRaw, viewDirWS, input.normal, output)]]
				[[MODULE:VERTEX:MatCap(input.normal, screenPos, output)]]

				return output;
#DISABLE_IMPL_ALL
			}

/// IF BYPASS_LIGHT_FALLOFF
			// Copy of LWRP's GetAdditionalLight() with different falloff calculation
			Light GetAdditionalLight_BypassFalloff(int i, float3 positionWS)
			{
				int perObjectLightIndex = GetPerObjectLightIndex(i);

				float3 lightPositionWS = _AdditionalLightsPosition[perObjectLightIndex].xyz;
				half4 distanceAndSpotAttenuation = _AdditionalLightsAttenuation[perObjectLightIndex];
				half4 spotDirection = _AdditionalLightsSpotDir[perObjectLightIndex];

				float3 lightVector = lightPositionWS - positionWS;
				float distanceSqr = max(dot(lightVector, lightVector), HALF_MIN);

				half3 lightDirection = half3(lightVector * rsqrt(distanceSqr));
				// original line:
				//half attenuation = DistanceAttenuation(distanceSqr, distanceAndSpotAttenuation.xy);
				half attenuation = saturate(1 - distanceSqr * distanceAndSpotAttenuation.x);
				attenuation *= AngleAttenuation(spotDirection.xyz, lightDirection, distanceAndSpotAttenuation.zw);

				Light light;
				light.direction = lightDirection;
				light.distanceAttenuation = attenuation;
				light.shadowAttenuation = AdditionalLightRealtimeShadow(perObjectLightIndex, positionWS);
				light.color = _AdditionalLightsColor[perObjectLightIndex].rgb;

				return light;
			}

///
#FRAGMENT, INPUT = input, OUTPUT = no_output
/// IF USE_VFACE
			half4 Fragment(Varyings input, half vFace : VFACE) : SV_Target
/// ELSE
			half4 Fragment(Varyings input) : SV_Target
///
			{
				UNITY_SETUP_INSTANCE_ID(input);
				UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);

#ENABLE_IMPL: float vFace, lbl = "Special/VFACE (Face direction)", help = "Indicates if the current face is back or front-facing. Should be used with custom Face Culling.", toggles = "USE_VFACE", custom_code_compatible = true
				float3 positionWS = input.worldPosAndFog.xyz;
				float3 normalWS = NormalizeNormalPerPixel(input.normal);
/// IF BACKFACE_LIGHTING_Z
				normalWS.z *= (vFace < 0) ? -1.0 : 1.0;
/// ELIF BACKFACE_LIGHTING_XYZ
				normalWS.xyz *= (vFace < 0) ? -1.0 : 1.0;
///
/// IF USE_VIEW_DIRECTION_FRAGMENT
				half3 viewDirWS = SafeNormalize(GetCameraPositionWS() - positionWS);
///
/// IF USE_TANGENT_FRAGMENT
				half3 tangentWS = input.[[INPUT_VALUE:tangent]];
///
/// IF USE_BITANGENT_FRAGMENT
				half3 bitangentWS = input.[[INPUT_VALUE:bitangent]];
///
#TODO implement POM from PerPixelDisplacement.hlsl instead of the old one?
/// IF BUMP
	/// IF BUMP_SHADER_FEATURE
				#if defined(_NORMALMAP)
	///
				[[MODULE:FRAGMENT:Normal Mapping:BUILD_TANGENT_MATRIX(tangentWS.xyz, bitangentWS.xyz, normalWS.xyz)]]
				[[MODULE:FRAGMENT:Normal Mapping:PARALLAX_SRP(viewDirWS, input.[[INPUT_VALUE:texcoord0]])]]
	/// IF BUMP_SHADER_FEATURE
				#endif
	///
///

				[[MODULE:FRAGMENT:Screen Space UV(input.[[INPUT_VALUE:screenPosition]], input)]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]

/// IF USE_NDV_FRAGMENT && USE_NDV_IGNORE_NORMAL_MAP
				half3 normalWSVertex = normalWS;
///
				[[MODULE:FRAGMENT:Texture Blending:INIT_UVS]]
/// IF BUMP && BUMP_SHADER_FEATURE
				#if defined(_NORMALMAP)
///
				[[MODULE:FRAGMENT:Normal Mapping:BUMP_SAMPLE()]]
				[[MODULE:FRAGMENT:Texture Blending:BUMP(normalMap)]]
				[[MODULE:FRAGMENT:Normal Mapping:UNPACK_BUMP_SRP(normalMap, normalTS)]]
				[[MODULE:FRAGMENT:Normal Mapping:APPLY_BUMP_SRP(normalWS, normalTS)]]
/// IF BUMP && BUMP_SHADER_FEATURE
				#endif
///

#ENABLE_IMPL: float ndv, lbl = "Special/N·V", help = "The dot product between the normal and view direction.", toggles = "USE_NDV_FRAGMENT", options = "(Use Min/Max Properties,USE_NDV_MIN_MAX_FRAG,config),(Invert,USE_NDV_INVERT_FRAG),(Ignore Normal Map,USE_NDV_IGNORE_NORMAL_MAP)"
/// IF USE_NDV_FRAGMENT
	/// IF USE_NDV_IGNORE_NORMAL_MAP
				half ndv = max(0, dot(viewDirWS, normalWSVertex));
	/// ELSE
				half ndv = max(0, dot(viewDirWS, normalWS));
	///
				half ndvRaw = ndv;
	/// IF USE_NDV_INVERT_FRAG
				ndv = 1 - ndv;
	///
	/// IF USE_NDV_MIN_MAX_FRAG
				ndv = smoothstep([[VALUE:NDV Min Frag]], [[VALUE:NDV Max Frag]], ndv);
	///

///
				// main texture
/// IF CUSTOM_ALBEDO
				half3 albedo = half3(1,1,1);
				half alpha = 1;
/// ELSE
				half3 albedo = [[VALUE:Albedo]].rgb;
				half alpha = [[VALUE:Alpha]];
///
				half3 emission = half3(0,0,0);
				[[MODULE:FRAGMENT:Dissolve(emission)]]
/// IF ALPHA_TESTING

	/// IF !ALPHA_TO_COVERAGE
				//Alpha Testing
				clip(alpha - [[VALUE:Cutoff]]);
	/// ELIF !ALPHA_TO_COVERAGE_RAW
				//Sharpen Alpha-to-Coverage
				alpha = (alpha - [[VALUE:Cutoff]]) / max(fwidth(alpha), 0.0001) + 0.5;
	///
///
/// IF TEXTURE_BLENDING || TRIPLANAR
				half4 albedoAlpha = half4(albedo, alpha);
	/// IF TRIPLANAR
				[[MODULE:FRAGMENT:Triplanar:INPUT(positionWS, normalWS, input.[[INPUT_VALUE:objPos]], input.[[INPUT_VALUE:objNormal]])]]
				[[MODULE:FRAGMENT:Triplanar(albedoAlpha, positionWS, input.[[INPUT_VALUE:objPos]])]]
	///
	/// IF TEXTURE_BLENDING
				[[MODULE:FRAGMENT:Texture Blending(albedoAlpha)]]
	///
				albedo = albedoAlpha.rgb;
				alpha = albedoAlpha.a;
///
				[[MODULE:FRAGMENT:AlbedoHSV(albedo)]]
				albedo *= [[VALUE:Main Color]].rgb;
/// IF HOOK_FINAL_ALBEDO
				albedo.rgb = [[SAMPLE_VALUE_SHADER_PROPERTY:Final Albedo]];
///

				// main light: direction, color, distanceAttenuation, shadowAttenuation
			#if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)
				float4 shadowCoord = input.shadowCoord;
			#elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)
				float4 shadowCoord = TransformWorldToShadowCoord(positionWS);
			#else
				float4 shadowCoord = float4(0, 0, 0, 0);
			#endif
				Light mainLight = GetMainLight(shadowCoord);

				// ambient or lightmap
/// IF ENABLE_LIGHTMAP
			#ifdef LIGHTMAP_ON
				// Normal is required in case Directional lightmaps are baked
				half3 bakedGI = SampleLightmap(input.[[INPUT_VALUE:uvLM]], normalWS);
				MixRealtimeAndBakedGI(mainLight, normalWS, bakedGI, half4(0, 0, 0, 0));
			#else
///
/// IF NO_AMBIENT
				half3 bakedGI = half3(0,0,0);
/// ELSE
	/// IF AMBIENT_SHADER_FEATURE
			#if defined(TCP2_AMBIENT)
	///
				// Samples SH fully per-pixel. SampleSHVertex and SampleSHPixel functions
				// are also defined in case you want to sample some terms per-vertex.
		/// IF AMBIENT_VIEW_DIR
				half3 bakedGI = SampleSH(viewDirWS);
		/// ELSE
				half3 bakedGI = SampleSH(normalWS);
		///
	/// IF AMBIENT_SHADER_FEATURE
			#else
				half3 bakedGI = half3(0,0,0);
			#endif
	///
///
/// IF ENABLE_LIGHTMAP
			#endif
///
/// IF OCCLUSION
				half occlusion = [[VALUE:Occlusion]];
/// ELSE
				half occlusion = 1;
///
				half3 indirectDiffuse = bakedGI;
#ENABLE_IMPL: float3 bakedGI, lbl = "Special/Indirect Diffuse", help = "The raw indirect diffuse color, as calculated by Unity."
/// IF AMBIENT_SHADER_FEATURE
			#if defined(TCP2_AMBIENT)
///
				[[MODULE:FRAGMENT:Custom Ambient(indirectDiffuse.rgb, normalWS)]]
				indirectDiffuse *= occlusion * albedo * [[VALUE:Ambient Intensity]];
				[[MODULE:FRAGMENT:Sketch:APPLY_AMBIENT(indirectDiffuse.rgb)]]
#ENABLE_IMPL: float3 indirectDiffuse, lbl = "Special/Ambient Color", help = "The indirect diffuse color, with albedo, occlusion and any custom ambient effects applied."
/// IF AMBIENT_SHADER_FEATURE
			#endif
///
/// IF EMISSION
				emission += [[VALUE:Emission]];
///

				[[MODULE:FRAGMENT:Triplanar:BUMP(normalWS)]]

				[[MODULE:FRAGMENT:MatCap(albedo, emission, normalWS, input)]]

				half3 lightDir = mainLight.direction;
/// IF HOOK_MAIN_LIGHT_DIR
				lightDir = normalize([[SAMPLE_VALUE_SHADER_PROPERTY:Main Light Direction]]);
///
				half3 lightColor = mainLight.color.rgb;
/// IF HOOK_MAIN_LIGHT_COLOR
				lightColor = [[SAMPLE_VALUE_SHADER_PROPERTY:Main Light Color]];
///
#ENABLE_IMPL: float3 lightColor, lbl = "Special/Light Color", compat = "all", help = "The color of the current light used."
				half atten = mainLight.shadowAttenuation * mainLight.distanceAttenuation;
/// IF HOOK_MAIN_LIGHT_ATTEN
				atten = [[SAMPLE_VALUE_SHADER_PROPERTY:Main Light Attenuation]];
///
#ENABLE_IMPL: float atten, lbl = "Special/Shadow Map", compat = "all", help = "The shadow map value for the current light."

				half ndl = dot(normalWS, lightDir);
#ENABLE_IMPL: float ndl, lbl = "Special/N·L", compat = "all", help = "The dot product between the normal and light direction."
				[[MODULE:FRAGMENT:NdotL Stylization:AFTER_NDL(ndl)]]
				half3 ramp;
				[[MODULE:FRAGMENT:Ramp Shading LWRP:MAIN_LIGHT(ramp, ndl)]]
/// IF USE_NDL_GRAYSCALE
				fixed3 rampGrayscale = ramp;
///
#ENABLE_IMPL: float3 rampGrayscale, lbl = "Special/N·L Ramp (Black and White)", compat = "all", toggles = "USE_NDL_GRAYSCALE", help = "N·L with the ramp modification before the highlight/shadow colors are applied."

				// apply attenuation
				ramp *= atten;

/// IF SHADOW_COLOR_MAIN_DIR
				[[MODULE:FRAGMENT:ShadowHSV(albedo, ramp)]]
				[[MODULE:FRAGMENT:Sketch(ramp)]]

				// highlight/shadow colors
	/// IF SHADOW_COLOR_LERP
				albedo = lerp([[VALUE:Shadow Color]], albedo, ramp);
				ramp = lerp(half3(1,1,1), [[VALUE:Highlight Color]], ramp);
	/// ELSE
				ramp = lerp([[VALUE:Shadow Color]], [[VALUE:Highlight Color]], ramp);
	///
	/// IF HOOK_RAMP
				ramp = [[SAMPLE_VALUE_SHADER_PROPERTY:Shading Ramp]];
	///
#ENABLE_IMPL: float3 ramp, lbl = "Special/N·L Ramp (With Colors)", compat = "all", help = "N·L with the ramp modification with the highlight/shadow colors applied."
				[[MODULE:FRAGMENT:NdotL Stylization:AFTER_RAMP(ndl, ramp)]]

				// output color
				half3 color = half3(0,0,0);
				[[MODULE:FRAGMENT:Rim Lighting(ndvRaw, color, albedo, normalWS, viewDirWS, input.screenPosition, ndl, atten, input)]]
				color += albedo * lightColor.rgb * ramp;
				[[MODULE:FRAGMENT:Sketch:APPLY(color.rgb)]]
/// ELSE
	/// IF HOOK_RAMP
				ramp = [[SAMPLE_VALUE_SHADER_PROPERTY:Shading Ramp]];
	///
				[[MODULE:FRAGMENT:NdotL Stylization:AFTER_RAMP(ndl, ramp)]]
				half3 color = half3(0,0,0);
				[[MODULE:FRAGMENT:Rim Lighting(ndvRaw, color, albedo, normalWS, viewDirWS, input.screenPosition, ndl, atten, input)]]
				half3 accumulatedRamp = ramp * max(lightColor.r, max(lightColor.g, lightColor.b));
				half3 accumulatedColors = ramp * lightColor.rgb;
///

				[[MODULE:FRAGMENT:Specular(color, normalWS, tangentWS, lightDir, viewDirWS, ndl, ndvRaw, atten)]]
				[[MODULE:FRAGMENT:Subsurface Scattering:LWRP_MAIN_LIGHT(color, normalWS, viewDirWS, albedo, lightColor, lightDir, atten)]]

				// Additional lights loop
/// IF !DISABLE_ADDITIONAL_LIGHTS
			#ifdef _ADDITIONAL_LIGHTS
	/// IF CLAMP_LIGHTS_INTENSITY_ADD
				half3 accumulatedColorsAdditional = half3(0, 0, 0);
	///
				uint additionalLightsCount = GetAdditionalLightsCount();
				for (uint lightIndex = 0u; lightIndex < additionalLightsCount; ++lightIndex)
				{
	/// IF BYPASS_LIGHT_FALLOFF
					Light light = GetAdditionalLight_BypassFalloff(lightIndex, positionWS);
					half atten = light.shadowAttenuation;
	/// ELSE
					Light light = GetAdditionalLight(lightIndex, positionWS);
					half atten = light.shadowAttenuation * light.distanceAttenuation;
	///
	/// IF HOOK_OTHER_LIGHTS_ATTEN
					atten = [[SAMPLE_VALUE_SHADER_PROPERTY:Additional Lights Attenuation]];
	///
					half3 lightDir = light.direction;
	/// IF HOOK_OTHER_LIGHTS_DIR
					lightDir = normalize([[SAMPLE_VALUE_SHADER_PROPERTY:Additional Lights Direction]]);
	///
					half3 lightColor = light.color.rgb;
	/// IF HOOK_OTHER_LIGHTS_COLOR
					lightColor = [[SAMPLE_VALUE_SHADER_PROPERTY:Additional Lights Color]];
	///

					half ndl = dot(normalWS, lightDir);
	/// IF BYPASS_LIGHT_FALLOFF
					ndl *= light.distanceAttenuation;
	///
					[[MODULE:FRAGMENT:NdotL Stylization:AFTER_NDL(ndl)]]
					half3 ramp;
					[[MODULE:FRAGMENT:Ramp Shading LWRP:ADDITIONAL_LIGHT(ramp, ndl)]]

	/// IF !ENABLE_SHADOW_2ND_LIGHTS && !ENABLE_SHADOW_2ND_LIGHTS_SAT
					// apply attenuation (shadowmaps & point/spot lights attenuation)
					ramp *= atten;
	///

	/// IF SHADOW_COLOR_MAIN_DIR
					// apply highlight color
		/// IF ENABLE_SHADOW_2ND_LIGHTS || ENABLE_SHADOW_2ND_LIGHTS_SAT
					ramp = lerp([[VALUE:Shadow Color]], [[VALUE:Highlight Color]], ramp);
			/// IF ENABLE_SHADOW_2ND_LIGHTS_SAT
					ramp *= saturate(atten);
			/// ELSE
					ramp *= atten;
			///
		/// ELSE
					ramp = lerp(half3(0,0,0), [[VALUE:Highlight Color]], ramp);
		///
					[[MODULE:FRAGMENT:NdotL Stylization:AFTER_RAMP(ndl, ramp)]]
#					[[MODULE:FRAGMENT:Sketch(ramp)]]

					// output color
					color += albedo * lightColor.rgb * ramp;
#					[[MODULE:FRAGMENT:Sketch:APPLY(color.rgb)]]
	/// ELSE
					[[MODULE:FRAGMENT:NdotL Stylization:AFTER_RAMP(ndl, ramp)]]
					accumulatedRamp += ramp * max(lightColor.r, max(lightColor.g, lightColor.b));
		/// IF CLAMP_LIGHTS_INTENSITY_ADD
					accumulatedColorsAdditional += ramp * lightColor.rgb;
		/// ELSE
					accumulatedColors += ramp * lightColor.rgb;
		///
	///

					[[MODULE:FRAGMENT:Specular(color, normalWS, tangentWS, lightDir, viewDirWS, ndl, ndvRaw, atten)]]
					[[MODULE:FRAGMENT:Subsurface Scattering:LWRP_ADDITIONAL_LIGHT(color, normalWS, viewDirWS, albedo, lightColor, lightDir, atten)]]
					[[MODULE:FRAGMENT:Rim Lighting:ADDITIONAL_LIGHT(ndvRaw, color, normalWS, viewDirWS, input.screenPosition, ndl, atten, input)]]
				}
			#endif
			#ifdef _ADDITIONAL_LIGHTS_VERTEX
				color += input.vertexLights * albedo;
			#endif
///
/// IF !SHADOW_COLOR_MAIN_DIR

				accumulatedRamp = saturate(accumulatedRamp);
	/// IF CLAMP_LIGHTS_INTENSITY_ADD && !DISABLE_ADDITIONAL_LIGHTS
			#ifdef _ADDITIONAL_LIGHTS
				accumulatedColorsAdditional = min(accumulatedColorsAdditional, [[VALUE:Max Light Intensity]]);
				accumulatedColors += accumulatedColorsAdditional;
			#endif
	/// ELIF CLAMP_LIGHTS_INTENSITY
				accumulatedColors = min(accumulatedColors, [[VALUE:Max Light Intensity]]);
	///
				[[MODULE:FRAGMENT:ShadowHSV(albedo,accumulatedRamp)]];
				[[MODULE:FRAGMENT:Sketch(accumulatedRamp)]]
	/// IF SHADOW_COLOR_LERP
				albedo = lerp([[VALUE:Shadow Color]], albedo, accumulatedRamp);
	///
				half3 shadowColor = (1 - accumulatedRamp.rgb) * [[VALUE:Shadow Color]];
				accumulatedRamp = accumulatedColors.rgb * [[VALUE:Highlight Color]] + shadowColor;
				color += albedo * accumulatedRamp;
				[[MODULE:FRAGMENT:Sketch:APPLY(color.rgb)]]
///

				// apply ambient
/// IF HOOK_FINAL_AMBIENT
				indirectDiffuse.rgb = [[SAMPLE_VALUE_SHADER_PROPERTY:Final Ambient]];
///
				color += indirectDiffuse;

/// IF GLOSSY_REFLECTIONS
	/// IF REFLECTION_SHADER_FEATURE
				#if defined(TCP2_REFLECTIONS)
	///
				half3 reflections = half3(0, 0, 0);
	
				// world reflection
				half reflectionRoughness = 1 - [[VALUE:Reflection Smoothness]];
				half3 reflectVector = reflect(-viewDirWS, normalWS);
				half3 indirectSpecular = GlossyEnvironmentReflection(reflectVector, reflectionRoughness, occlusion);
				half reflectionRoughness4 = max(pow(reflectionRoughness, 4), 6.103515625e-5);
				float surfaceReductionRefl = 1.0 / (reflectionRoughness4 + 1.0);
				reflections += indirectSpecular * surfaceReductionRefl * [[VALUE:Reflection Color]];

				[[MODULE:FRAGMENT:Reflection(reflections, normalWS, viewDirWS, ndvRaw)]]

				color.rgb += reflections;
	/// IF REFLECTION_SHADER_FEATURE
				#endif
	///
/// ELSE
	#if_not_empty

				half3 reflections = half3(0, 0, 0);
	#start_not_empty_block
				[[MODULE:FRAGMENT:Reflection(reflections, normalWS, viewDirWS, ndvRaw)]]
	#end_not_empty_block
				color.rgb += reflections;
	#end_not_empty
///

				color += emission;
/// IF FOG

				// Mix the pixel color with fogColor. You can optionally use MixFogColor to override the fogColor with a custom one.
				float fogFactor = input.worldPosAndFog.w;
				color = MixFog(color, fogFactor);
///
				[[MODULE:FRAGMENT:Vertical Fog(color.rgb, input.worldPosAndFog.xyz)]]
/// IF HOOK_FINAL_COLOR

				color.rgb = [[SAMPLE_VALUE_SHADER_PROPERTY:Final Color]];
///

				return half4(color, alpha);
#DISABLE_IMPL_ALL
			}
			ENDHLSL
		}

/// IF OUTLINE
		//Outline
		Pass
		{
			Name "Outline"
	/// IF OUTLINE_URP_FEATURE
			Tags { "LightMode" = "Outline" }
	///
			Cull Front
	/// IF OUTLINE_ZSMOOTH
			Offset [[VALUE:Outline Offset Factor]],[[VALUE:Outline Offset Units]]
	///
	/// IF OUTLINE_BLENDING
			Blend [[VALUE:Outline Blend Source]] [[VALUE:Outline Blend Destination]]
	/// ELIF OUTLINE_OPAQUE
			Blend Off
	///
	/// IF OUTLINE_BEHIND_STENCIL
			Stencil
			{
				Ref [[VALUE:Outline Stencil Reference]]
				Comp NotEqual
				Pass Keep
			}
	///

			HLSLPROGRAM
			#pragma vertex vertex_outline
			#pragma fragment fragment_outline
			#pragma target @%SHADER_TARGET%@
			#pragma multi_compile _ TCP2_COLORS_AS_NORMALS TCP2_TANGENT_AS_NORMALS TCP2_UV1_AS_NORMALS TCP2_UV2_AS_NORMALS TCP2_UV3_AS_NORMALS TCP2_UV4_AS_NORMALS
			#pragma multi_compile _ TCP2_UV_NORMALS_FULL TCP2_UV_NORMALS_ZW
			#pragma multi_compile_instancing
			ENDHLSL
		}
///
#PASS
		// Depth & Shadow Caster Passes
		HLSLINCLUDE
		#if defined(SHADOW_CASTER_PASS) || defined(DEPTH_ONLY_PASS)

			#define fixed half
			#define fixed2 half2
			#define fixed3 half3
			#define fixed4 half4

			float3 _LightDirection;

/// IF !ENABLE_SRP_BATCHER
			CBUFFER_START(UnityPerMaterial)
			[[VARIABLES_INCLUDE]]
			CBUFFER_END
			[[VARIABLES_GPU_INSTANCING]]
///

			struct Attributes
			{
				float4 vertex   : POSITION;
				float3 normal   : NORMAL;
/// IF VERTEXMOTION_NORMAL || CURVED_WORLD_NORMAL
				float4 tangent : TANGENT;
///
				[[VERTEX_INPUT_TEXCOORDS]]
/// IF USE_VERTEX_COLORS_VERT
				half4 vertexColor : COLOR;
///
				UNITY_VERTEX_INPUT_INSTANCE_ID
			};

			struct Varyings
			{
				float4 positionCS     : SV_POSITION;
/// IF CURVED_WORLD || USE_WORLD_NORMAL_FRAGMENT
				float3 normal         : NORMAL;
///
				[[INPUT_STRUCT_SEMANTICS:0]]
#INPUT_VARIABLES
/// IF USE_VERTEX_COLORS_FRAG
				half4 vertexColor;
///
/// IF USE_SCREEN_POSITION_FRAGMENT
				float4 screenPosition;
///
/// IF USE_WORLD_POSITION_FRAGMENT
				float3 positionWS;
///
				[[MODULE:INPUT]]
#END
			#if defined(DEPTH_ONLY_PASS)
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			#endif
			};

			float4 GetShadowPositionHClip(Attributes input)
			{
				float3 positionWS = TransformObjectToWorld(input.vertex.xyz);
				float3 normalWS = TransformObjectToWorldNormal(input.normal);

				float4 positionCS = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

			#if UNITY_REVERSED_Z
				positionCS.z = min(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE);
			#else
				positionCS.z = max(positionCS.z, positionCS.w * UNITY_NEAR_CLIP_VALUE);
			#endif

				return positionCS;
			}

#VERTEX, INPUT = input, OUTPUT = output
			Varyings ShadowDepthPassVertex(Attributes input)
			{
				Varyings output;
				UNITY_SETUP_INSTANCE_ID(input);
				#if defined(DEPTH_ONLY_PASS)
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);
				#endif

/// IF USE_WORLD_POSITION_UV_VERTEX
				float3 worldPosUv = mul(unity_ObjectToWorld, input.vertex).xyz;
///
				[[VERTEX_TEXCOORDS]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]

				[[MODULE:VERTEX:VertExmotion:LWRP(input.vertex, input.normal, input.tangent.xyz)]]
				[[MODULE:VERTEX:CurvedWorld(input.vertex, input.normal, input.tangent)]]
/// IF USE_VIEW_DIRECTION_VERTEX || USE_CLIP_POSITION_VERTEX || USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX || USE_WORLD_POSITION_FRAGMENT
				VertexPositionInputs vertexInput = GetVertexPositionInputs(input.vertex.xyz);
///
/// IF USE_WORLD_NORMAL_VERTEX || USE_WORLD_NORMAL_FRAGMENT
				VertexNormalInputs vertexNormalInput = GetVertexNormalInputs(input.normal);
///
/// IF USE_VIEW_DIRECTION_VERTEX
				half3 viewDirWS = SafeNormalize(GetCameraPositionWS() - vertexInput.positionWS);
///
/// IF USE_NDV_VERTEX
				half ndv = max(0, dot(viewDirWS, vertexNormalInput.normalWS));
				half ndvRaw = ndv;
	/// IF USE_NDV_INVERT_VERT
				ndv = 1 - ndv;
	///
	/// IF USE_NDV_MIN_MAX_VERT
				ndv = smoothstep([[VALUE:NDV Min Vert]], [[VALUE:NDV Max Vert]], ndv);
	///
///
/// IF HOOK_VERTEX_POSITION
				input.vertex.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position]];
///
				float3 worldPos = mul(unity_ObjectToWorld, input.vertex).xyz;
/// IF HOOK_VERTEX_POSITION_WORLD
				worldPos.xyz = [[SAMPLE_VALUE_SHADER_PROPERTY:Vertex Position World]];
///
				[[MODULE:VERTEX:Wind(worldPos.xyz)]]
/// IF APPLY_WORLD_POSITION
				input.vertex.xyz = mul(unity_WorldToObject, float4(worldPos, 1)).xyz;
///
/// IF USE_SCREEN_POSITION_FRAGMENT || USE_SCREEN_POSITION_VERTEX

				//Screen Space UV
				float4 screenPos = ComputeScreenPos(vertexInput.positionCS);
	/// IF USE_SCREEN_POSITION_FRAGMENT
				output.[[INPUT_VALUE:screenPosition]] = screenPos;
	///
///
				[[MODULE:VERTEX:Screen Space UV(screenPos, vertexInput.positionCS, output)]]
/// IF USE_VERTEX_COLORS_FRAG
				output.vertexColor = input.vertexColor;
///
/// IF USE_WORLD_NORMAL_FRAGMENT
				output.normal = NormalizeNormalPerVertex(vertexNormalInput.normalWS);
///
/// IF USE_WORLD_POSITION_FRAGMENT
				output.[[INPUT_VALUE:positionWS]] = vertexInput.positionWS;
///

				#if defined(DEPTH_ONLY_PASS)
					output.positionCS = TransformObjectToHClip(input.vertex.xyz);
				#elif defined(SHADOW_CASTER_PASS)
					output.positionCS = GetShadowPositionHClip(input);
				#else
					output.positionCS = float4(0,0,0,0);
				#endif

				return output;
			}

#FRAGMENT, INPUT = input, OUTPUT = no_output
			half4 ShadowDepthPassFragment(Varyings input) : SV_TARGET
			{
				#if defined(DEPTH_ONLY_PASS)
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);
				#endif

/// IF USE_WORLD_POSITION_FRAGMENT
				float3 positionWS = input.[[INPUT_VALUE:positionWS]];
///

				[[MODULE:FRAGMENT:Screen Space UV(input.[[INPUT_VALUE:screenPosition]], input)]]
				[[SAMPLE_CUSTOM_PROPERTIES]]
				[[SAMPLE_SHADER_PROPERTIES]]

/// IF USE_WORLD_NORMAL_FRAGMENT
				float3 normalWS = NormalizeNormalPerPixel(input.normal);
///
/// IF USE_VIEW_DIRECTION_FRAGMENT
				half3 viewDirWS = SafeNormalize(GetCameraPositionWS() - positionWS);
///
/// IF USE_NDV_FRAGMENT
#		/// IF USE_NDV_IGNORE_NORMAL_MAP
#				half ndv = max(0, dot(viewDirWS, normalWSVertex));
#		/// ELSE
				half ndv = max(0, dot(viewDirWS, normalWS));
#		///
				half ndvRaw = ndv;
	/// IF USE_NDV_INVERT_FRAG
				ndv = 1 - ndv;
	///
	/// IF USE_NDV_MIN_MAX_FRAG
				ndv = smoothstep([[VALUE:NDV Min Frag]], [[VALUE:NDV Max Frag]], ndv);
	///

///
/// IF CUSTOM_ALBEDO
				half3 albedo = half3(1,1,1);
				half alpha = 1;
/// ELSE
				half3 albedo = [[VALUE:Albedo]].rgb;
				half alpha = [[VALUE:Alpha]];
///
				half3 emission = half3(0,0,0);
				[[MODULE:FRAGMENT:Dissolve(emission)]]
/// IF ALPHA_TESTING

	/// IF !ALPHA_TO_COVERAGE
				//Alpha Testing
				clip(alpha - [[VALUE:Cutoff]]);
	/// ELIF !ALPHA_TO_COVERAGE_RAW
				//Sharpen Alpha-to-Coverage
				alpha = (alpha - [[VALUE:Cutoff]]) / max(fwidth(alpha), 0.0001) + 0.5;
	///
///
/// IF ALPHA_TESTING && ALPHA_TO_COVERAGE
				return alpha;
/// ELSE
				return 0;
///
			}

		#endif
		ENDHLSL
/// IF !DISABLE_SHADOW_CASTING

		Pass
		{
			Name "ShadowCaster"
			Tags{"LightMode" = "ShadowCaster"}

	/// IF ALPHA_TESTING && ALPHA_TO_COVERAGE
			AlphaToMask On
	///
			ZWrite On
			ZTest LEqual
	/// IF CULLING
			Cull [[VALUE:Face Culling]]
	///

			HLSLPROGRAM
			// Required to compile gles 2.0 with standard srp library
			#pragma prefer_hlslcc gles
			#pragma exclude_renderers d3d11_9x
			#pragma target 2.0

			// using simple #define doesn't work, we have to use this instead
			#pragma multi_compile SHADOW_CASTER_PASS

			// -------------------------------------
			// Material Keywords
			//#pragma shader_feature _ALPHATEST_ON
			//#pragma shader_feature _GLOSSINESS_FROM_BASE_ALPHA

			//--------------------------------------
			// GPU Instancing
			#pragma multi_compile_instancing

			#pragma vertex ShadowDepthPassVertex
			#pragma fragment ShadowDepthPassFragment
			
	#if_not_empty
			//--------------------------------------
			// Toony Colors Pro 2 keywords
	#start_not_empty_block
			[[MODULE:SHADER_FEATURES_BLOCK:Wind]]
			[[MODULE:SHADER_FEATURES_BLOCK:Dissolve]]
	#end_not_empty_block
	#end_not_empty

			#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
			#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl"

			ENDHLSL
		}
///

		Pass
		{
			Name "DepthOnly"
			Tags{"LightMode" = "DepthOnly"}

/// IF ALPHA_TESTING && ALPHA_TO_COVERAGE
			AlphaToMask On
///
			ZWrite On
			ColorMask 0
/// IF CULLING
			Cull [[VALUE:Face Culling]]
///

			HLSLPROGRAM

			// Required to compile gles 2.0 with standard srp library
			#pragma prefer_hlslcc gles
			#pragma exclude_renderers d3d11_9x
			#pragma target 2.0

			// -------------------------------------
			// Material Keywords
			// #pragma shader_feature _ALPHATEST_ON
			// #pragma shader_feature _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

			//--------------------------------------
			// GPU Instancing
			#pragma multi_compile_instancing

			// using simple #define doesn't work, we have to use this instead
			#pragma multi_compile DEPTH_ONLY_PASS

			#pragma vertex ShadowDepthPassVertex
			#pragma fragment ShadowDepthPassFragment
			
			
	#if_not_empty
			//--------------------------------------
			// Toony Colors Pro 2 keywords
	#start_not_empty_block
			[[MODULE:SHADER_FEATURES_BLOCK:Wind]]
			[[MODULE:SHADER_FEATURES_BLOCK:Dissolve]]
	#end_not_empty_block
	#end_not_empty

			ENDHLSL
		}

		// Depth prepass
		// UsePass "Universal Render Pipeline/Lit/DepthOnly"

/// IF ENABLE_META_PASS
		// Used for Baking GI. This pass is stripped from build.
		UsePass "Universal Render Pipeline/Lit/Meta"
///
	}

	FallBack "Hidden/InternalErrorShader"
	CustomEditor "ToonyColorsPro.ShaderGenerator.MaterialInspector_SG2"
}